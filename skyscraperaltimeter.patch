diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..6894a30
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,17 @@
+# Python
+venv/
+__pycache__/
+*.pyc
+.env
+*.log
+
+# iOS
+.DS_Store
+build/
+*.xcuserstate
+DerivedData/
+
+# General
+logs/
+.vscode/
+.idea/
diff --git a/README.md b/README.md
index 725710b..62ece1a 100644
--- a/README.md
+++ b/README.md
@@ -1 +1,17 @@
 # SKYSCRAPERALTIMETER
+
+Live iPhone altimeter relay for broadcast graphics.
+
+## Overview
+SKYSCRAPERALTIMETER captures barometric altitude changes on iOS, relays them to a lightweight FastAPI server, and exposes the latest reading for graphics systems or a web viewer.
+
+## Components
+- `server/`: FastAPI ingest + latest relay service
+- `ios/`: SwiftUI iOS app
+- `web/`: Optional static monitoring viewer
+- `docs/`: API and deployment documentation
+
+## Quick Start
+(Coming soon)
+
+No open-source license. Proprietary use.
diff --git a/docs/API.md b/docs/API.md
new file mode 100644
index 0000000..6303cb5
--- /dev/null
+++ b/docs/API.md
@@ -0,0 +1,24 @@
+# API
+
+## POST /ingest
+Authenticated with `Authorization: Bearer <token>`.
+
+Required fields:
+- device_id (string)
+- timestamp_ms (int)
+- relative_altitude_m (float)
+- pressure_kpa (float)
+- vertical_gain_m (float)
+- net_change_m (float)
+- seq (int)
+
+Optional fields:
+- battery_level (float)
+- is_charging (bool)
+- app_version (string)
+
+## GET /latest
+Returns the most recent payload with cache disabled. Returns 204 when no data is available.
+
+## GET /health
+Returns server status and last received timestamp.
diff --git a/docs/DEPLOYMENT.md b/docs/DEPLOYMENT.md
new file mode 100644
index 0000000..7147314
--- /dev/null
+++ b/docs/DEPLOYMENT.md
@@ -0,0 +1,3 @@
+# Deployment
+
+Run the FastAPI server on a laptop or small Linux host on the same network as the iOS device and graphics system. Configure firewall rules to allow the ingest and latest endpoints.
diff --git a/docs/TROUBLESHOOTING.md b/docs/TROUBLESHOOTING.md
new file mode 100644
index 0000000..95d53c2
--- /dev/null
+++ b/docs/TROUBLESHOOTING.md
@@ -0,0 +1,5 @@
+# Troubleshooting
+
+- Ensure `INGEST_TOKEN` is set and matches the iOS app configuration.
+- Verify the server is reachable on the configured port.
+- Use `server/test_endpoints.sh` to validate connectivity.
diff --git a/ios/SkyscraperAltimeter/README.md b/ios/SkyscraperAltimeter/README.md
new file mode 100644
index 0000000..5c9bd28
--- /dev/null
+++ b/ios/SkyscraperAltimeter/README.md
@@ -0,0 +1,16 @@
+# SkyscraperAltimeter iOS App
+
+## Requirements
+- Xcode 15.0+
+- iOS 16.0 deployment target
+
+## Build
+1. Open `SkyscraperAltimeter.xcodeproj` in Xcode.
+2. Select a device or simulator.
+3. Build and run.
+
+## Configuration
+Set the server URL and ingest token in Settings before first use.
+
+## Permissions
+The app requests motion access on first run to read barometric altitude changes.
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/AltimeterManager.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/AltimeterManager.swift
new file mode 100644
index 0000000..09ac542
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/AltimeterManager.swift
@@ -0,0 +1,87 @@
+import CoreMotion
+import Foundation
+
+struct AltimeterReading {
+    let relativeAltitudeM: Double
+    let pressureKPa: Double
+    let verticalGainM: Double
+    let netChangeM: Double
+    let seq: Int
+}
+
+class AltimeterManager: ObservableObject {
+    @Published var isActive: Bool = false
+    @Published var relativeAltitudeM: Double = 0.0
+    @Published var pressureKPa: Double = 0.0
+    @Published var verticalGainM: Double = 0.0
+    @Published var netChangeM: Double = 0.0
+    @Published var lastError: String?
+    @Published var sequenceNumber: Int = 0
+
+    private let altimeter = CMAltimeter()
+    private var startAltitude: Double?
+    private var previousAltitude: Double?
+
+    var onUpdate: ((AltimeterReading) -> Void)?
+
+    func start() {
+        guard CMAltimeter.isRelativeAltitudeAvailable() else {
+            lastError = "Relative altitude is not available on this device."
+            return
+        }
+
+        startAltitude = nil
+        previousAltitude = nil
+        verticalGainM = 0.0
+        netChangeM = 0.0
+        sequenceNumber = 0
+        lastError = nil
+
+        altimeter.startRelativeAltitudeUpdates(to: OperationQueue.main) { [weak self] data, error in
+            guard let self else { return }
+            if let error = error {
+                self.lastError = error.localizedDescription
+                return
+            }
+            guard let data = data else { return }
+
+            let currentAltitude = data.relativeAltitude.doubleValue
+            let pressureKPa = data.pressure.doubleValue * 10.0
+
+            if self.startAltitude == nil {
+                self.startAltitude = currentAltitude
+            }
+
+            if let previous = self.previousAltitude {
+                let delta = currentAltitude - previous
+                if delta > 0 {
+                    self.verticalGainM += delta
+                }
+            }
+
+            let baseline = self.startAltitude ?? currentAltitude
+            self.netChangeM = currentAltitude - baseline
+
+            self.relativeAltitudeM = currentAltitude
+            self.pressureKPa = pressureKPa
+            self.sequenceNumber += 1
+            self.previousAltitude = currentAltitude
+
+            let reading = AltimeterReading(
+                relativeAltitudeM: currentAltitude,
+                pressureKPa: pressureKPa,
+                verticalGainM: self.verticalGainM,
+                netChangeM: self.netChangeM,
+                seq: self.sequenceNumber
+            )
+            self.onUpdate?(reading)
+        }
+
+        isActive = true
+    }
+
+    func stop() {
+        altimeter.stopRelativeAltitudeUpdates()
+        isActive = false
+    }
+}
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/ContentView.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/ContentView.swift
new file mode 100644
index 0000000..dd85191
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/ContentView.swift
@@ -0,0 +1,118 @@
+import SwiftUI
+
+struct ContentView: View {
+    @StateObject private var altimeterManager = AltimeterManager()
+    @StateObject private var networkManager = NetworkManager()
+    @State private var showSettings = false
+
+    var body: some View {
+        VStack(spacing: 16) {
+            HStack {
+                Text("Skyscraper Altimeter")
+                    .font(.title)
+                    .bold()
+
+                Spacer()
+
+                statusBadge
+            }
+
+            if altimeterManager.isActive {
+                VStack(alignment: .leading, spacing: 8) {
+                    Text(String(format: "%.2f m", altimeterManager.relativeAltitudeM))
+                        .font(.system(size: 48, weight: .bold))
+                    Text(String(format: "Net Change: %.2f m", altimeterManager.netChangeM))
+                    Text(String(format: "Vertical Gain: %.2f m", altimeterManager.verticalGainM))
+                    Text(String(format: "Pressure: %.2f kPa", altimeterManager.pressureKPa))
+                    Text("Sequence: \(altimeterManager.sequenceNumber)")
+                    Text("Last Sent: \(lastSentText)")
+                    Text("Queued: \(networkManager.queuedPayloads)")
+                }
+                .frame(maxWidth: .infinity, alignment: .leading)
+            } else {
+                Text("Altimeter is stopped")
+                    .foregroundColor(.secondary)
+            }
+            
+            if let error = altimeterManager.lastError {
+                Text(error)
+                    .foregroundColor(.red)
+                    .font(.caption)
+                    .frame(maxWidth: .infinity, alignment: .leading)
+            }
+
+            Spacer()
+
+            HStack(spacing: 16) {
+                if altimeterManager.isActive {
+                    Button("Stop") {
+                        altimeterManager.stop()
+                        networkManager.stopSending()
+                    }
+                    .buttonStyle(.borderedProminent)
+                    .tint(.red)
+                } else {
+                    Button("Start") {
+                        altimeterManager.start()
+                        networkManager.startSending()
+                    }
+                    .buttonStyle(.borderedProminent)
+                }
+            }
+        }
+        .padding()
+        .toolbar {
+            ToolbarItem(placement: .topBarTrailing) {
+                Button {
+                    showSettings = true
+                } label: {
+                    Image(systemName: "gear")
+                }
+            }
+        }
+        .sheet(isPresented: $showSettings) {
+            SettingsView(networkManager: networkManager)
+        }
+        .onAppear {
+            altimeterManager.onUpdate = { reading in
+                networkManager.enqueuePayload(
+                    relativeAltitudeM: reading.relativeAltitudeM,
+                    pressureKPa: reading.pressureKPa,
+                    verticalGainM: reading.verticalGainM,
+                    netChangeM: reading.netChangeM,
+                    seq: reading.seq,
+                    battery: nil,
+                    isCharging: nil
+                )
+            }
+        }
+    }
+
+    private var statusBadge: some View {
+        let color: Color
+        switch networkManager.connectionStatus {
+        case "connected":
+            color = .green
+        case "connecting":
+            color = .yellow
+        default:
+            color = .red
+        }
+
+        return Text(networkManager.connectionStatus)
+            .font(.caption)
+            .padding(.horizontal, 8)
+            .padding(.vertical, 4)
+            .background(color.opacity(0.2))
+            .foregroundColor(color)
+            .cornerRadius(8)
+    }
+
+    private var lastSentText: String {
+        guard let lastSent = networkManager.lastSentTime else {
+            return "never"
+        }
+        let interval = Int(Date().timeIntervalSince(lastSent))
+        return "\(interval)s ago"
+    }
+}
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/Info.plist b/ios/SkyscraperAltimeter/SkyscraperAltimeter/Info.plist
new file mode 100644
index 0000000..aa5d74a
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/Info.plist
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>NSMotionUsageDescription</key>
+  <string>This app uses motion sensors to measure altitude changes during climbs.</string>
+  <key>UIBackgroundModes</key>
+  <array>
+    <string>location</string>
+  </array>
+</dict>
+</plist>
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/KeychainHelper.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/KeychainHelper.swift
new file mode 100644
index 0000000..eaddd4b
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/KeychainHelper.swift
@@ -0,0 +1,46 @@
+import Foundation
+import Security
+
+struct KeychainHelper {
+    static func save(key: String, value: String) -> Bool {
+        guard let data = value.data(using: .utf8) else { return false }
+
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrAccount as String: key,
+            kSecValueData as String: data
+        ]
+
+        SecItemDelete(query as CFDictionary)
+        let status = SecItemAdd(query as CFDictionary, nil)
+        return status == errSecSuccess
+    }
+
+    static func load(key: String) -> String? {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrAccount as String: key,
+            kSecReturnData as String: kCFBooleanTrue as Any,
+            kSecMatchLimit as String: kSecMatchLimitOne
+        ]
+
+        var item: CFTypeRef?
+        let status = SecItemCopyMatching(query as CFDictionary, &item)
+        guard status == errSecSuccess,
+              let data = item as? Data,
+              let value = String(data: data, encoding: .utf8) else {
+            return nil
+        }
+        return value
+    }
+
+    static func delete(key: String) -> Bool {
+        let query: [String: Any] = [
+            kSecClass as String: kSecClassGenericPassword,
+            kSecAttrAccount as String: key
+        ]
+
+        let status = SecItemDelete(query as CFDictionary)
+        return status == errSecSuccess || status == errSecItemNotFound
+    }
+}
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/NetworkManager.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/NetworkManager.swift
new file mode 100644
index 0000000..f73d067
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/NetworkManager.swift
@@ -0,0 +1,145 @@
+import Foundation
+
+class NetworkManager: ObservableObject {
+    @Published var connectionStatus: String = "disconnected"
+    @Published var lastSentTime: Date?
+    @Published var queuedPayloads: Int = 0
+
+    private let deviceId: String
+    private var serverURL: String
+    private var ingestToken: String
+    private var sendInterval: TimeInterval = 5
+    private var payloadQueue: [[String: Any]] = []
+    private var timer: Timer?
+    private var retryCount: Int = 0
+    private var isSending: Bool = false
+
+    init() {
+        let defaults = UserDefaults.standard
+        if let storedDeviceId = defaults.string(forKey: "deviceId") {
+            deviceId = storedDeviceId
+        } else {
+            let newId = UUID().uuidString
+            defaults.set(newId, forKey: "deviceId")
+            deviceId = newId
+        }
+
+        serverURL = KeychainHelper.load(key: "serverURL") ?? defaults.string(forKey: "serverURL") ?? ""
+        ingestToken = KeychainHelper.load(key: "ingestToken") ?? defaults.string(forKey: "ingestToken") ?? ""
+        if let storedInterval = defaults.object(forKey: "sendInterval") as? Double {
+            sendInterval = storedInterval
+        }
+        connectionStatus = "disconnected"
+    }
+
+    func configure(serverURL: String, token: String, interval: TimeInterval) {
+        self.serverURL = serverURL
+        ingestToken = token
+        sendInterval = interval
+
+        _ = KeychainHelper.save(key: "serverURL", value: serverURL)
+        _ = KeychainHelper.save(key: "ingestToken", value: token)
+        UserDefaults.standard.set(serverURL, forKey: "serverURL")
+        UserDefaults.standard.set(token, forKey: "ingestToken")
+        UserDefaults.standard.set(interval, forKey: "sendInterval")
+        UserDefaults.standard.set(deviceId, forKey: "deviceId")
+    }
+
+    func startSending() {
+        timer?.invalidate()
+        timer = Timer.scheduledTimer(withTimeInterval: sendInterval, repeats: true) { [weak self] _ in
+            self?.sendNextPayload()
+        }
+    }
+
+    func stopSending() {
+        timer?.invalidate()
+        timer = nil
+    }
+
+    func enqueuePayload(
+        relativeAltitudeM: Double,
+        pressureKPa: Double,
+        verticalGainM: Double,
+        netChangeM: Double,
+        seq: Int,
+        battery: Double?,
+        isCharging: Bool?
+    ) {
+        var payload: [String: Any] = [
+            "device_id": deviceId,
+            "timestamp_ms": Int(Date().timeIntervalSince1970 * 1000),
+            "relative_altitude_m": relativeAltitudeM,
+            "pressure_kpa": pressureKPa,
+            "vertical_gain_m": verticalGainM,
+            "net_change_m": netChangeM,
+            "seq": seq,
+            "app_version": "1.0.0"
+        ]
+
+        if let battery {
+            payload["battery_level"] = battery
+        }
+        if let isCharging {
+            payload["is_charging"] = isCharging
+        }
+
+        payloadQueue.append(payload)
+        if payloadQueue.count > 50 {
+            payloadQueue.removeFirst()
+        }
+        queuedPayloads = payloadQueue.count
+    }
+
+    private func sendNextPayload() {
+        guard !isSending else { return }
+        guard !payloadQueue.isEmpty else {
+            connectionStatus = "connected"
+            return
+        }
+        guard !serverURL.isEmpty, !ingestToken.isEmpty else {
+            connectionStatus = "error"
+            return
+        }
+        guard let url = URL(string: "\(serverURL)/ingest") else {
+            connectionStatus = "error"
+            return
+        }
+
+        isSending = true
+        connectionStatus = "connecting"
+
+        let payload = payloadQueue[0]
+        let bodyData = try? JSONSerialization.data(withJSONObject: payload, options: [])
+
+        var request = URLRequest(url: url)
+        request.httpMethod = "POST"
+        request.setValue("Bearer \(ingestToken)", forHTTPHeaderField: "Authorization")
+        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+        request.httpBody = bodyData
+
+        URLSession.shared.dataTask(with: request) { [weak self] _, response, error in
+            DispatchQueue.main.async {
+                guard let self else { return }
+                self.isSending = false
+
+                if let httpResponse = response as? HTTPURLResponse,
+                   (200...299).contains(httpResponse.statusCode),
+                   error == nil {
+                    self.payloadQueue.removeFirst()
+                    self.queuedPayloads = self.payloadQueue.count
+                    self.lastSentTime = Date()
+                    self.connectionStatus = "connected"
+                    self.retryCount = 0
+                } else {
+                    self.retryCount += 1
+                    self.connectionStatus = "error"
+                    let delay = min(pow(2.0, Double(self.retryCount)), 60)
+                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
+                        self.sendNextPayload()
+                    }
+                }
+            }
+        }.resume()
+    }
+}
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/SettingsView.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/SettingsView.swift
new file mode 100644
index 0000000..fb4964e
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/SettingsView.swift
@@ -0,0 +1,47 @@
+import SwiftUI
+
+struct SettingsView: View {
+    @Environment(\.dismiss) private var dismiss
+    @ObservedObject var networkManager: NetworkManager
+
+    @State private var serverURL: String = ""
+    @State private var ingestToken: String = ""
+    @State private var sendInterval: Double = 5
+
+    var body: some View {
+        NavigationView {
+            Form {
+                Section(header: Text("Server")) {
+                    TextField("http://192.168.1.100:8787", text: $serverURL)
+                        .textInputAutocapitalization(.never)
+                        .autocorrectionDisabled(true)
+                    SecureField("Ingest Token", text: $ingestToken)
+                }
+
+                Section(header: Text("Send Interval")) {
+                    Stepper(value: $sendInterval, in: 3...10, step: 1) {
+                        Text("\(Int(sendInterval)) seconds")
+                    }
+                }
+            }
+            .navigationTitle("Settings")
+            .toolbar {
+                ToolbarItem(placement: .confirmationAction) {
+                    Button("Save") {
+                        networkManager.configure(
+                            serverURL: serverURL,
+                            token: ingestToken,
+                            interval: sendInterval
+                        )
+                        dismiss()
+                    }
+                }
+            }
+            .onAppear {
+                serverURL = UserDefaults.standard.string(forKey: "serverURL") ?? ""
+                ingestToken = UserDefaults.standard.string(forKey: "ingestToken") ?? ""
+                sendInterval = UserDefaults.standard.object(forKey: "sendInterval") as? Double ?? 5
+            }
+        }
+    }
+}
diff --git a/ios/SkyscraperAltimeter/SkyscraperAltimeter/SkyscraperAltimeterApp.swift b/ios/SkyscraperAltimeter/SkyscraperAltimeter/SkyscraperAltimeterApp.swift
new file mode 100644
index 0000000..d50f553
--- /dev/null
+++ b/ios/SkyscraperAltimeter/SkyscraperAltimeter/SkyscraperAltimeterApp.swift
@@ -0,0 +1,10 @@
+import SwiftUI
+
+@main
+struct SkyscraperAltimeterApp: App {
+    var body: some Scene {
+        WindowGroup {
+            ContentView()
+        }
+    }
+}
diff --git a/server/.env.example b/server/.env.example
new file mode 100644
index 0000000..c59ddb3
--- /dev/null
+++ b/server/.env.example
@@ -0,0 +1,2 @@
+PORT=8787
+INGEST_TOKEN=your_secure_token_here
diff --git a/server/README.md b/server/README.md
new file mode 100644
index 0000000..a302a3f
--- /dev/null
+++ b/server/README.md
@@ -0,0 +1,21 @@
+# Server
+
+## Setup
+```bash
+python3 -m venv venv
+source venv/bin/activate
+pip install -r requirements.txt
+```
+
+Create `.env` from `.env.example` and set `INGEST_TOKEN`.
+
+## Run
+```bash
+uvicorn app:app --host 0.0.0.0 --port 8787 --reload
+```
+
+## Test
+```bash
+chmod +x test_endpoints.sh
+./test_endpoints.sh
+```
diff --git a/server/app.py b/server/app.py
new file mode 100644
index 0000000..aeab052
--- /dev/null
+++ b/server/app.py
@@ -0,0 +1,94 @@
+import os
+import time
+from typing import Any, Dict, Optional
+
+from dotenv import load_dotenv
+from fastapi import FastAPI, Header, HTTPException, Request, Response
+from fastapi.middleware.cors import CORSMiddleware
+from fastapi.responses import JSONResponse
+from pydantic import BaseModel
+
+load_dotenv()
+
+PORT = int(os.getenv("PORT", "8787"))
+INGEST_TOKEN = os.getenv("INGEST_TOKEN")
+
+app = FastAPI()
+
+app.add_middleware(
+    CORSMiddleware,
+    allow_origins=["*"],
+    allow_methods=["GET"],
+    allow_headers=["*"]
+)
+
+latest_payload: Optional[Dict[str, Any]] = None
+
+
+class IngestPayload(BaseModel):
+    device_id: str
+    timestamp_ms: int
+    relative_altitude_m: float
+    pressure_kpa: float
+    vertical_gain_m: float
+    net_change_m: float
+    seq: int
+    battery_level: Optional[float] = None
+    is_charging: Optional[bool] = None
+    app_version: Optional[str] = None
+
+
+@app.on_event("startup")
+def startup() -> None:
+    if not INGEST_TOKEN:
+        raise RuntimeError("INGEST_TOKEN environment variable is required")
+    print(f"Server starting on port {PORT}")
+    print("Ingest endpoint secured with token authentication")
+
+
+@app.post("/ingest")
+async def ingest(
+    payload: IngestPayload,
+    request: Request,
+    authorization: Optional[str] = Header(default=None),
+) -> Dict[str, bool]:
+    if not authorization or not authorization.startswith("Bearer "):
+        raise HTTPException(status_code=401, detail="Unauthorized")
+    token = authorization.split("Bearer ", 1)[1]
+    if token != INGEST_TOKEN:
+        raise HTTPException(status_code=401, detail="Unauthorized")
+
+    received_at_ms = int(time.time() * 1000)
+    source_ip = request.client.host if request.client else None
+
+    stored_payload = payload.dict()
+    stored_payload["received_at_ms"] = received_at_ms
+    stored_payload["source_ip"] = source_ip
+
+    global latest_payload
+    latest_payload = stored_payload
+
+    return {"ok": True}
+
+
+@app.get("/latest")
+async def latest() -> Response:
+    if latest_payload is None:
+        return Response(status_code=204)
+
+    headers = {
+        "Cache-Control": "no-store, no-cache, must-revalidate, proxy-revalidate",
+        "Pragma": "no-cache",
+        "Expires": "0",
+    }
+
+    return JSONResponse(content=latest_payload, headers=headers)
+
+
+@app.get("/health")
+async def health() -> Dict[str, Any]:
+    return {
+        "ok": True,
+        "has_data": latest_payload is not None,
+        "last_received_at_ms": latest_payload.get("received_at_ms") if latest_payload else None,
+    }
diff --git a/server/requirements.txt b/server/requirements.txt
new file mode 100644
index 0000000..9e97be9
--- /dev/null
+++ b/server/requirements.txt
@@ -0,0 +1,3 @@
+fastapi==0.104.1
+uvicorn[standard]==0.24.0
+python-dotenv==1.0.0
diff --git a/server/test_endpoints.sh b/server/test_endpoints.sh
new file mode 100644
index 0000000..c1b14c6
--- /dev/null
+++ b/server/test_endpoints.sh
@@ -0,0 +1,42 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+BASE_URL=${BASE_URL:-"http://localhost:8787"}
+TOKEN=${INGEST_TOKEN:-"your_secure_token_here"}
+
+curl -s -X POST "$BASE_URL/ingest" \
+  -H "Authorization: Bearer $TOKEN" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "device_id": "test-device",
+    "timestamp_ms": 1700000000000,
+    "relative_altitude_m": 12.3,
+    "pressure_kpa": 101.2,
+    "vertical_gain_m": 15.0,
+    "net_change_m": 10.0,
+    "seq": 1,
+    "battery_level": 0.88,
+    "is_charging": false,
+    "app_version": "1.0.0"
+  }'
+
+curl -s -X POST "$BASE_URL/ingest" \
+  -H "Authorization: Bearer invalid_token" \
+  -H "Content-Type: application/json" \
+  -d '{
+    "device_id": "test-device",
+    "timestamp_ms": 1700000000001,
+    "relative_altitude_m": 12.4,
+    "pressure_kpa": 101.1,
+    "vertical_gain_m": 15.1,
+    "net_change_m": 10.1,
+    "seq": 2
+  }' || true
+
+curl -s "$BASE_URL/latest"
+
+echo
+
+curl -s "$BASE_URL/health"
+
+echo
diff --git a/web/README.md b/web/README.md
new file mode 100644
index 0000000..344c196
--- /dev/null
+++ b/web/README.md
@@ -0,0 +1,3 @@
+# Web Viewer
+
+Open `index.html` via a static server that can reach the FastAPI server. The viewer polls `/latest` every 3 seconds.
diff --git a/web/index.html b/web/index.html
new file mode 100644
index 0000000..cc446a3
--- /dev/null
+++ b/web/index.html
@@ -0,0 +1,44 @@
+<!doctype html>
+<html lang="en">
+  <head>
+    <meta charset="utf-8" />
+    <meta name="viewport" content="width=device-width, initial-scale=1" />
+    <title>Skyscraper Altimeter Viewer</title>
+    <style>
+      body {
+        font-family: system-ui, sans-serif;
+        margin: 2rem;
+      }
+      pre {
+        background: #f6f8fa;
+        padding: 1rem;
+        border-radius: 8px;
+      }
+    </style>
+  </head>
+  <body>
+    <h1>Skyscraper Altimeter Viewer</h1>
+    <p>Polling <code>/latest</code> every 3 seconds.</p>
+    <pre id="output">Waiting for data...</pre>
+
+    <script>
+      const output = document.getElementById("output");
+      async function poll() {
+        try {
+          const response = await fetch("/latest", { cache: "no-store" });
+          if (response.status === 204) {
+            output.textContent = "No data yet.";
+            return;
+          }
+          const data = await response.json();
+          output.textContent = JSON.stringify(data, null, 2);
+        } catch (error) {
+          output.textContent = `Error: ${error}`;
+        }
+      }
+
+      poll();
+      setInterval(poll, 3000);
+    </script>
+  </body>
+</html>

